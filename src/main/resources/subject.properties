subject.definition.expressions= <u><b>Expressions</b></u> are essential building blocks of any Java program, usually created to produce a new value,\
although sometimes an expression assigns a value to a variable. Expressions are built using values,\
variables, operators and method calls.
subject.information.expressions= While an expression frequently produces a result, it doesn't always. There are \
three <b>types of expressions</b> in Java:\
<br>&#10150	Those that produce a value, i.e., the result of\
<br>(1	+ 1)\
<br>&#10150 Those that assign a variable, for example\
<br>(v = 10)\
<br>&#10150	Those that have no result but might have a "side effect" because an expression can include a wide\
range of elements such as method invocations or increment operators that modify the state (i.e., memory)\
of a program.
subject.example.expressions=To see a few more expression examples take a look at the code below. The \
 text that is highlighted in bold are the expressions:<br>\
 <br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
<br>&emsp;&emsp;&emsp;int <b>cadence = 0;</b>\
<br>&emsp;&emsp;&emsp;<b>anArray[0] = 100;</b>\
<br>&emsp;&emsp;&emsp;System.out.println(<b>"Element 1 at index 0: " + anArray[0]</b>);\
<br><br>\
<br>&emsp;&emsp;&emsp;int <b>result = 1 + 2;</b><span style="color:grey;"> // result is now 3</span>\
<br>&emsp;&emsp;&emsp;if (<b>value1 == value2</b>) \
<br>&emsp;&emsp;&emsp;System.out.println(<b>"value1 == value2"</b>);</div>

subject.definition.variables=Variable is name of reserved area allocated in memory. In other words, it is a name of memory location.\
It is a combination of <b>"vary + able"</b> that means its value can be changed.\
<br> &bull; The value stored in a variable can be changed during program execution.\
<br> &bull; A variable is only a name given to a memory location, all the operations done on the variable effects that memory location.\
<br> &bull; In Java, all the variables must be declared before use.

subject.information.variables=There are three types of variables in Java:\
<br><b>&#10154</b> <b>Local Variable</b> - A variable declared inside the body of the method is called local variable. You can use\
this variable only within that method and the other methods in the class aren't even aware that the\
variable exists. A local variable cannot be defined with "static" keyword.\
<br><b>&#10154</b> <b>Instance Variable</b> - A variable declared inside the class but outside the body of the method, is called\
instance variable. It is not declared as static. It is called instance variable because its value is\
instance specific and is not shared among instances.\
<br><b>&#10154</b> <b>Static variable</b> - A variable which is declared as static is called static variable. It cannot be local.\
You can create a single copy of static variable and share among all the instances of the class. Memory\
allocation for static variable happens only once when the class is loaded in the memory.

subject.example.variables=To create a variable, you must specify the type and assign it a value:\
 <br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
 &emsp;&emsp;&emsp;type variable = value;</div>\
<br><br>Where <b>type</b> is one of Java's types (such as int or String), and <b>variable</b> is the name of the variable (such as x or name). The equal sign is used to assign values to the variable.\
<br><br>Here's a demonstration of how to declare variables of different types:\
<br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
<br>&emsp;&emsp;&emsp;int myNum = 5;\
<br>&emsp;&emsp;&emsp;float myFloatNum = 5.99f;\
<br>&emsp;&emsp;&emsp;char myLetter = 'D';\
<br>&emsp;&emsp;&emsp;boolean myBool = true;\
<br>&emsp;&emsp;&emsp;String myText = "Hello";</b></div>

subject.definition.primitives=The Java programming language is statically-typed, which means that all variables must first be declared before they can be used.\
This involves stating the variable's type and name, as you've already seen:\
<br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
<b>&emsp;&emsp;&emsp;int gear = 1;</b></div>\
<br>Doing so tells your program that a field named "gear" exists, holds numerical data, and has an initial value of "1".\
A variable's data type determines the values it may contain, plus the operations that may be performed on it. In addition to int, the Java programming language supports seven other primitive data types. \
A primitive type is predefined by the language and is named by a reserved keyword.

subject.information.primitives=There are 8 types of primitive data types: boolean data type, byte data type, char data typeshort data\
type, int data type, long data type, float data type, double data type.\
<br><br><b style = "color:orange">Boolean</b> - The Boolean data type is used to store only two possible values: true and false. This data type\
is used for simple flags that track true/false conditions. The Boolean data type specifies one bit of\
information, but its "size" can't be defined precisely.\
<br>Example: Boolean one = false\
<br><br><b style = "color:orange">Byte</b> - The byte data type is an example of primitive data type. It isan 8-bit signed two's complement integer.\
   Its value-range lies between -128 to 127 (inclusive). Its minimum value is -128 and maximum value is 127. \
  Its default value is 0.\
The byte data type is used to save memory in large arrays where the memory savings is most required. \
  It saves space because a byte is 4 times smaller than an integer. It can also be used in place of "int" data type.\
<br>Example: byte a = 10, byte b = -20\
<br><br><b style = "color:orange">Short</b> - The short data type is a 16-bit signed two's complement integer. Its value-range lies between -32,768 to \
  32,767 (inclusive). Its minimum value is -32,768 and maximum value is 32,767. Its default value is 0.The short data \
  type can also be used to save memory just like byte data type. A short data type is 2 times smaller than an integer.\
<br>Example: short s = 10000, short r = -5000\
<br><br><b style = "color:orange">Int</b> - The int data type is a 32-bit signed two's complement integer. Its value-range lies between \
  - 2,147,483,648 (-2^31) to 2,147,483,647 (2^31 -1) (inclusive). Its minimum value is - 2,147,483,648 and maximum \
  value is 2,147,483,647. Its default value is 0. The int data type is generally used as a default data type for \
  integral values unless if there is no problem about memory.\
<br>Example: int a = 100000, int b = -200000\
<br><br><b style = "color:orange">Long</b> - The long data type is a 64-bit two's complement integer. Its value-range lies between\
   -9,223,372,036,854,775,808(-2^63) to 9,223,372,036,854,775,807(2^63 -1)(inclusive). Its minimum value is \
  - 9,223,372,036,854,775,808and maximum value is 9,223,372,036,854,775,807. Its default value is 0. The long data \
  type is used when you need a range of values more than those provided by int.\
<br>Example: long a = 100000L, long b = -200000L\
<br><br><b style = "color:orange">Float</b> - The float data type is a single-precision 32-bit IEEE 754 floating point.Its value range is unlimited. \
  It is recommended to use a float (instead of double) if you need to save memory in large arrays of floating point \
  numbers. The float data type should never be used for precise values, such as currency. Its default value is 0.0F.\
<br>Example: float f1 = 234.5f\
<br><br><b style = "color:orange">Double</b> - The double data type is a double-precision 64-bit IEEE 754 floating point. Its value range is unlimited. \
  The double data type is generally used for decimal values just like float. The double data type also should never \
  be used for precise values, such as currency. Its default value is 0.0d.\
<br>Example: double d1 = 12.3\
<br><br><b style = "color:orange">Char</b> - The char data type is a single 16-bit Unicode character. Its value-range lies between \
  '\u0000' (or 0) to '\uffff' (or 65,535 inclusive).The char data type is used to store characters.\
<br>Example: char letterA = 'A'.

subject.definition.logical.operators=<b>Logical operator</b> is a symbol or word used to connect two or more expressions \
such that the value of the compound expression produced depends only on that of the original expressions \
and on the meaning of the operator.\
Logical operators are mainly used to control program flow. Usually, you will find them as\
part of an if, a while, or some other control statement.

subject.information.logical.operators=The Logical operators are:\
<br>op1 <b>&&</b> op2\
<br>-- Performs a logical <b>AND</b> of the two operands.\
<br>op1 <b>||</b> op2\
<br>-- Performs a logical <b>OR</b> of the two operands.\
<br><b>!</b>op1\
<br>-- Performs a logical <b>NOT</b> of the operand.\
<br>\
<br>The concept of logical operators is simple. They allow a program to make a decision based on multiple conditions.\
   Each operand is considered a condition that can be evaluated to a true or false value. Then the value of the \
   conditions is used to determine the overall value of the op1 operator op2 or !op1 grouping. The following examples \
   demonstrate different ways that logical conditions can be used.\
The && operator is used to determine whether both operands or conditions are true and.pl.

subject.example.logical.operators=<i>For example:</i>\
<br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
&emsp;&emsp;if ($firstVar == 10 && $secondVar == 9) {\
<br>&emsp;&emsp;&emsp;print("Error!");\
<br>&emsp;&emsp;}</div>\
<br>If either of the two conditions is false or incorrect, then the print command is bypassed.\
<br>The <b>||</b> operator is used to determine whether either of the conditions is true.\
<br>\
<br><i>For example:</i>\
  <br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
&emsp;&emsp;if ($firstVar == 9 || $firstVar == 10) {\
<br>&emsp;&emsp;&emsp;print("Error!");\
 <br>&emsp;&emsp; }</div>\
<br>If either of the two conditions is true, then the print command is run.\
<br>Caution If the first operand of the <b>||</b> operator evaluates to true, the second operand will not be evaluated. \
  This could be a source of bugs if you are not careful.\
<br>For instance, in the following code fragment:\
<br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
&emsp;&emsp;if ($firstVar++ || $secondVar++) {<br>&emsp;&emsp;&emsp; print("\n"); <br>&emsp;&emsp;}</div>\
<br>variable $secondVar will not be incremented if $firstVar++ evaluates to true.\
<br>The <b>!</b> operator is used to convert true values to false and false values to true. In other words, \
  it inverts a value. Perl considers any non-zero value to be true-even string values. \
  <br>\
  <br><i>For example:</i>\
<br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
&emsp;&emsp;$firstVar = 10;\
<br>&emsp;&emsp;$secondVar = !$firstVar;\
<br>&emsp;&emsp;if ($secondVar == 0) {\
<br>&emsp;&emsp;&emsp;print("zero\n");\
<br>&emsp;&emsp;}</div>\
<br>is equal to 0 - and the program produces the following output:\
<br>zero\
  <br>\
<br>You could replace the 10 in the first line with "ten," 'ten,' or any non-zero, non-null value.

subject.definition.casting=Casting is the action of converting between two different data types such as converting an \
  int to a double and vice versa. Examine the code below for examples of casting.

subject.information.casting=There are two types of casting:\
<br><b>&#10173 Primitive Type Casting</b>\
<br>Casting between primitive types enables you to convert the value of one type to another primitive type is called Primitive \
Type Casting. This is most commonly occurs with the numeric data types . But boolean primitive type can never be used in a cast.\
 Its values must be either true or false and cannot be used in a casting operation.\
 <br>\
<br>There are two basic types of Primitive Type Casting: <i>widening and narrowing.</i>\
<br>&#10139;<b><i>Widening conversions (Implicit casting)</i></b>\
<br>A value of narrower(lower size) data type can be converted to a value of a broader (higher size) data type without loss of\
   information is called Widening conversion. This conversion also known as implicit casting (see widening example).\
  <br>\
<br>&emsp;&emsp;&emsp;&emsp;<u>Widening conversions in Java</u>\
<br>&emsp;&emsp;&emsp;&emsp;&#8210 From a byte to a short, an int, a long, a float, or a double\
<br>&emsp;&emsp;&emsp;&emsp;&#8210 From a short to an int, a long, a float, or a double\
<br>&emsp;&emsp;&emsp;&emsp;&#8210 From a char to an int, a long, a float, or a double\
<br>&emsp;&emsp;&emsp;&emsp;&#8210 From an int to a long, a float, or a double\
<br>&emsp;&emsp;&emsp;&emsp;&#8210 From a long to a float or a double\
<br>&emsp;&emsp;&emsp;&emsp;&#8210 From a float to a double\
  <br>\
<br><b>NOTE:</b> A widening conversion of an int or a long value to a float value , or of a long value to double value, \
  may result in loss of precision . That is, the result may lose some of the least significant bits of the value. \
  In this case, the resulting floating-point value will be a correctly rounded version of the integer value, using IEEE 754 round-to-nearest mode.\
<br>\
 <br><b>&#10139; Narrowing Conversions (Explicit Casting)</b>\
<br>Converting from a broader data type (higher size) to a narrower data type (lower size) is called narrowing conversion. \
  This type of conversion can result in loss of information. This is not done implicitly by the JVM and requires explicit casting (see narrowing example).\
<br>\
<br>&emsp;&emsp;&emsp;&emsp;<u>Narrowing conversions in Java</u>\
<br>&emsp;&emsp;&emsp;&emsp;&#8210 From a byte to a char\
<br>&emsp;&emsp;&emsp;&emsp;&#8210 From a short to a byte or a char\
<br>&emsp;&emsp;&emsp;&emsp;&#8210 From a char to a byte or a short\
<br>&emsp;&emsp;&emsp;&emsp;&#8210 From an int to a byte, a short, or a char\
<br>&emsp;&emsp;&emsp;&emsp;&#8210 From a long to a byte, a short, a char, or an int\
<br>&emsp;&emsp;&emsp;&emsp;&#8210 From a float to a byte, a short, a char, an int, or a long\
<br>&emsp;&emsp;&emsp;&emsp;&#8210 From a double to a byte, a short, a char, an int, a long, or a float\
  <br>\
<br>An implicit conversion is performed automatically, with no additional input from the developer. An explicit conversion,\
   on the other hand, is not performed automatically and is, instead, dictated by the developer.\
  <br>\
<br>&#10173<b>Reference Type Casting</b>\
<br>Objects of classes also can be cast into objects of other classes when the source and destination classes are related by\
 inheritance and one class is a subclass of the other. The cast can be to its own class type or to one of its subclass or \
  superclass types or interfaces. There are compile-time rules and runtime rules for casting in java. \
  <br>\
  <br>There are two types of <b>Reference Type</b> Casting in Java, they are :\
<br>&#10139<b><i>Upcasting</i></b>\
<br>Is casting a subtype object into a supertype and this is. In Java, we need not add an explicit cast and you can \
  assign the object directly. Compiler will understand and cast the value to supertype. By doing this, we are lifting an object to\
   a generic level. If we prefer, we can add an explicit cast and no issues.\
  <br>\
<br>&#10139<b><i>Downcasting</i></b>\
<br>Casting a supertype to a subtype is called downcast. This is the mostly done cast. By doing this we are telling the compiler\
   that the value stored in the base object is of a super type. Then we are asking the runtime to assign the value. Because of \
  downcast we get access to methods of the subtype on that object. When performing downcasting, that you’re well aware of the type \
  of object you'll be casting.\
  <br>\
<br><i><u>!!Note:</u></i> Supercasting is always allowed, but subcasting involves a type check and can throw a ClassCastException.
subject.example.casting=<div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
<br>&ensp;CastingExample.java\
<br>&ensp;package exlcode;\
<br>&ensp;public class CastingExample { \
<br>&ensp;// this converts 15.23 into an integer\
<br>&ensp;public static int exampleVariableOne = (int) 15.23;\
<br>&ensp;public static double exampleVariableTwo = exampleVariableOne;\
<br>&ensp;public static void main(String[] args) {\
<br>&emsp;System.out.println(exampleVariableOne);\
<br>&emsp;System.out.println(exampleVariableTwo);\
<br>&emsp;}\
<br>&ensp;}</div>\
<br>We just converted the double value 15.23 into an integer, which left only the whole number and the decimal places\
   to be cut off. There is no rounding, it just ignores the numbers after the decimal point during casting. When you \
  convert an int to a double, a decimal point will be added to match with the structure of a double. \
  <br>\
<br><b><i>For example</i></b>\
  <br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
 &emsp;double varOne = (double) 15;</div> \
  <br>assigns 15.0 to varOne.\
<br>Even though it is possible to convert an int to a double without casting, it is best practice to always use casting for\
   precision and thorough logic. Also, be careful with the loss of precision when converting data types.\
   <br>i.e. losing decimal points is losing precision.\
  <br>\
<br><b><i>Widening example:</i></b>\
  <br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
&emsp;int i = 1000;\
<br>&emsp;double j = i;</div>\
<br>In the  example, an Automatic Type Casting take place, that is an integer variable (4 Byte) converted into double variable(8 Byte).\
   The casting happened from a lower data type to a higher data type, so there is no data loss .\
  <br>\
 <br><b><i> Narrowing example:</i></b>\
  <br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
&emsp;double i = 100.7;\
<br>&emsp;int j = (int) i;</div>\
<br> In above example a double variable(8 Byte) converted into integer variable (4 Byte) . The casting happened from a higher \
  data type to a lower data type, so can result in loss of information.

subject.definition.ternary.operator= <b>Ternary Operator (Short Hand If...Else)</b>\
<br>There is also a short-hand if else, which is known as the ternary operator because it consists of three operands. \
  Java ternary operator is the only conditional operator that takes three operands. It's a one-liner replacement for if-then-else \
  statement and used a lot in Java programming.
subject.information.ternary.operator= We can use the ternary operator in place of if-else conditions or even switch \
   conditions using nested ternary operators. Although it follows the same algorithm as of if-else statement, the conditional \
   operator takes less space and helps to write the if-else statements in the shortest way possible.\
<br>\
<img style="width:600px; height:400px; border:3px solid grey; border-radius: 18px; margin-top:17px;"  src="/images/ternary.jpg">

subject.example.ternary.operator=  <b>Syntax:</b>\
  <br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
<i>&ensp;variable = (condition) ? expressionTrue :  expressionFalse;</i></div>\
<br>Instead of writing:\
 <br>\
<br><i>Example:</i>\
<br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
&ensp;int time = 20;\
<br>&ensp;if (time < 18) {\
<br>&emsp;System.out.println("Good day.");\
<br>&ensp;}else {\
<br>&emsp;System.out.println("Good evening.");}</div>\
<br>Using the Ternary operator you can simply write:\
<br>\
<br><i>Example:</i>\
<br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
&ensp;int=time = 20;\
<br>&ensp;String result = (time < 18) ? "Good day." : "Good evening.";\
<br>&emsp;System.out.println(result);</div>

subject.definition.keywords=<b><u>Java keywords</b></u> are also known as <b><u>reserved words</b></u>. Keywords are particular \
words which act as a key to a code. These are predefined words by Java so they cannot be used as a \
variable or an object name.

subject.information.keywords=A list of Java keywords or reserved words are given below:\
<br><b><i>1.	abstract:</b></i> Java abstract keyword is used to declare abstract class. Abstract class can provide the implementation of interface. It can have abstract and non-abstract methods.\
<br><b><i>2.	boolean:</b></i> Java boolean keyword is used to declare a variable as a boolean type. It can hold True and False values only.\
<br><b><i>3.	break:</b></i> Java break keyword is used to break loop or switch statement. It breaks the current flow of the program at specified condition.\
<br><b><i>4.	byte:</b></i> Java byte keyword is used to declare a variable that can hold an 8-bit data values.\
<br><b><i>5.	case:</b></i> Java case keyword is used to with the switch statements to mark blocks of text.\
<br><b><i>6.	catch:</b></i> Java catch keyword is used to catch the exceptions generated by try statements. It must be used after the try block only.\
<br><b><i>7.	char:</b></i> Java char keyword is used to declare a variable that can hold unsigned 16-bit Unicode characters\
<br><b><i>8.	class:</b></i> Java class keyword is used to declare a class.\
<br><b><i>9.	continue:</b></i> Java continue keyword is used to continue the loop. It continues the current flow of the program and skips the remaining code at the specified condition.\
<br><b><i>10.	default:</b></i> Java default keyword is used to specify the default block of code in a switch statement.\
<br><b><i>11.	do:</b></i> Java do keyword is used in control statement to declare a loop. It can iterate a part of the program several times.\
<br><b><i>12.	double:</b></i> Java double keyword is used to declare a variable that can hold a 64-bit floating-point numbers.\
<br><b><i>13.	else:</b></i> Java else keyword is used to indicate the alternative branches in an if statement.\
<br><b><i>14.	enum:</b></i> Java enum keyword is used to define a fixed set of constants. Enum constructors are always private or default.\
<br><b><i>15.	extends:</b></i> Java extends keyword is used to indicate that a class is derived from another class or interface.\
<br><b><i>16.	final:</b></i> Java final keyword is used to indicate that a variable holds a constant value. It is applied with a variable. It is used to restrict the user.\
<br><b><i>17.	finally:</b></i> Java finally keyword indicates a block of code in a try-catch structure. This block is always executed whether exception is handled or not.\
<br><b><i>18.	float:</b></i> Java float keyword is used to declare a variable that can hold a 32-bit floating-point number.\
<br><b><i>19.	for:</b></i> Java for keyword is used to start a for loop. It is used to execute a set of instructions/functions repeatedly when some conditions become true. If the number of iteration is fixed, it is recommended to use for loop.\
<br><b><i>20.	if:</b></i> Java if keyword tests the condition. It executes the if block if condition is true.\
<br><b><i>21.	implements:</b></i> Java implements keyword is used to implement an interface.\
<br><b><i>22.	import:</b></i> Java import keyword makes classes and interfaces available and accessible to the current source code.\
<br><b><i>23.	instanceof:</b></i> Java instanceof keyword is used to test whether the object is an instance of the specified class or implements an interface.\
<br><b><i>24.	int:</b></i> Java int keyword is used to declare a variable that can hold a 32-bit signed integer.\
<br><b><i>25.	interface:</b></i> Java interface keyword is used to declare an interface. It can have only abstract methods.\
<br><b><i>26.	long:</b></i> Java long keyword is used to declare a variable that can hold a 64-bit integer.\
<br><b><i>27.	native:</b></i> Java native keyword is used to specify that a method is implemented in native code using JNI (Java Native Interface).\
<br><b><i>28.	new:</b></i> Java new keyword is used to create new objects.\
<br><b><i>29.	null:</b></i> Java null keyword is used to indicate that a reference does not refer to anything. It removes the garbage value.\
<br><b><i>30.	package:</b></i> Java package keyword is used to declare a Java package that includes the classes.\
<br><b><i>31.	private:</b></i> Java private keyword is an access modifier. It is used to indicate that a method or variable may be accessed only in the class in which it is declared.\
<br><b><i>32.	protected:</b></i> Java protected keyword is an access modifier. It can be accessible within package and outside the package but through inheritance only. It can't be applied on the class.\
<br><b><i>33.	public:</b></i> Java public keyword is an access modifier. It is used to indicate that an item is accessible anywhere. It has the widest scope among all other modifiers.\
<br><b><i>34.	return:</b></i> Java return keyword is used to return from a method when its execution is complete.\
<br><b><i>35.	short:</b></i> Java short keyword is used to declare a variable that can hold a 16-bit integer.\
<br><b><i>36.	static:</b></i> Java static keyword is used to indicate that a variable or method is a class method. The static keyword in Java is used for memory management mainly.\
<br><b><i>37.	strictfp:</b></i> Java strictfp is used to restrict the floating-point calculations to ensure portability.\
<br><b><i>38.	super:</b></i> Java super keyword is a reference variable that is used to refer parent class object. It can be used to invoke immediate parent class method.\
<br<b><i>>39.	switch:</b></i> The Java switch keyword contains a switch statement that executes code based on test value. The switch statement tests the equality of a variable against multiple values.\
<br><b><i>40.	synchronized:</b></i> Java synchronized keyword is used to specify the critical sections or methods in multithreaded code.\
<br><b><i>41.	this:</b></i> Java this keyword can be used to refer the current object in a method or constructor.\
<br><b><i>42.	throw:</b></i> The Java throw keyword is used to explicitly throw an exception. The throw keyword is mainly used to throw custom exception. It is followed by an instance.\
<br><b><i>43.	throws:</b></i> The Java throws keyword is used to declare an exception. Checked exception can be propagated with throws.\
<br><b><i>44.	transient:</b></i> Java transient keyword is used in serialization. If you define any data member as transient, it will not be serialized.\
<br><b><i>45.	try:</b></i> Java try keyword is used to start a block of code that will be tested for exceptions. The try block must be followed by either catch or finally block.\
<br><b><i>46.	void:</b></i> Java void keyword is used to specify that a method does not have a return value.\
<br><b><i>47.	volatile:</b></i> Java volatile keyword is used to indicate that a variable may change asynchronously.\
<br><b><i>48.	while:</b></i> Java while keyword is used to start a while loop. This loop iterates a part of the program several times. If the number of iteration is not fixed, it is recommended to use while loop.
subject.example.keywords=

subject.definition.statements,.whitespace.&.indentation= <b><i>Java statements</b></i> are instructions that tell the programming language what to do. A basic statement, like an assignment statement,\
  assigns a value to a variable, as shown in the first example.\
<br><b><i>White space </b></i>consists mostly of the space character that you produce by hitting the space bar on your keyboard\
   and that is commonly used to separate words in sentences. \
<br><b><i>Indentation</b></i> is used to make our code readable to other users, easier to edit, display how the braces match up and show \
  the logic of the program in an organized fashion. Please look at example two below to see how indentation of the if-else \
  statement makes it easy to see what is happening.

subject.information.statements,.whitespace.&.indentation= All Java statements must end in a semicolon (;).\
  This tells Java that it should attempt to process all information up to that semicolon.\
  There are four other white space characters in Java, the horizontal tab, the form feed, the carriage return, \
  and the linefeed. Depending on your platform, when you hit the return or enter key, you get either a carriage return\
 (the Mac), a linefeed (Unix) or both (DOS, Windows, VMS). This produces a hard line break in the source code text.\
Outside of String literals Java treats all white space and runs of white space (more than one white space character in\
 immediate succession) the same. It's used to separate tokens, and one space is as good as seven spaces, a tab and two \
 carriage returns. Exactly which white space characters you use is primarily a result of what's convenient for human beings \
  reading the code. The compiler doesn't care.\
The goal of indentation is to show the logic of our program. Keeping indentation consistent throughout a program is essential.\
 For statements inside a left and right brace, increase the indenting by two spaces. When another pair of braces is nested \
  inside those braces, increase the indentation by another two spaces. It is a good idea to line up the braces vertically. \
  Keep in mind that the function of indentation is to make the program more readable and understandable, which saves an\
   immense amount of time when editing or refining your code.

subject.example.statements,.whitespace.&.indentation=<i>Example 1</i>\
<br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
&emsp;&emsp;double entryFee = 15.75;</div>\
<br><i>Example 2 </i>\
<br>\
<br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
&emsp;IndentationExample.java\
<br>&emsp;package exlcode;\
<br>&emsp;public class IndentationExample {\
<br>&emsp;&emsp;<span style="color:grey;">// standard indenting increases by 2 spaces as shown below</span>\
<br>&emsp;&emsp;<span style="color:grey;">// braces are used even when optional</span>\
<br>&emsp;public static void main(String[] args) {\
<br>&emsp;&emsp;<span style="color:grey;">// neat indenting:</span>\
<br>&emsp;&emsp;<span style="color:grey;">// if-else will be explained in Unit 5</span>\
<br>&emsp;&emsp;if (true) {\
<br>&emsp;&emsp;System.out.println("True");\
<br>&emsp;&emsp;} else {\
<br>&emsp;&emsp;System.out.println("False");\
<br>&emsp;&emsp;}\
<br>&emsp;&emsp;// no indenting:\
<br>&emsp;&emsp;if(true)    \
<br>&emsp;&emsp;System.out.println("True");\
<br>&emsp;&emsp;else  \
<br>&emsp;System.out.println("False");\
<br>&emsp;}\
<br>}</div>

subject.definition.code.blocks=A block is a group of zero or more statements between balanced braces and can be used anywhere a single\
statement is allowed. Java likes to keep things between the lines, no make that curly braces({}).

subject.information.code.blocks=
subject.example.code.blocks=This how we can start and stop a code block in Java. Braces gives the compiler a heads up of where we want to start({) and end(}).\
<br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
&ensp;package com.javablocks;\
<br>&ensp;public class JavaCodeBlocks {\
<br>&emsp;&ensp;public static void main (String arg[]) {\
<br>&emsp;&ensp;System.out.println(&ldquo;Inside the Java code block&rdquo;);\
<br>&emsp;&ensp;}\
<br>&ensp;}</div>\
<br>\
In our first example we have not one but two code blocks. First, for the JavaCodeBlock class with the open brace on line 3. Next on line \
  4 we open the main method with another open brace. Then we close it up on line 6 for the main method and line 7 for the class.\
   A pro tip, most IDEs will highlight the closing brace when you put your cursor by the open brace and vice versa too.\
<br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
&emsp;package com.javablocks;\
<br>&emsp;public class void main(String arg[]) {\
<br>&emsp;&emsp;Boolean check = true;\
<br>&emsp;&emsp;If(check) {\
<br>&emsp;&emsp;System.out.println(“Check is true”);\
<br>&emsp;&emsp;}else {\
<br>&emsp;&emsp;System.out.println(“Check is false”);\
<br>&emsp;&emsp;&emsp;}\
<br>&emsp;&emsp;{\
<br>&emsp;&emsp;System.out.println(“Just a random code block”);\
<br>&emsp;&emsp;&emsp;}\
<br>&emsp;&emsp;}\
<br>&emsp;}</div>\
<br><br>\
In this example we have an if else with each having their own code block. We don't have to but helps with readability. Later on we have\
   a random code block too. It looks like it should be wrong if you are new to development but it is perfectly legitimate.\
Java has a few types of code blocks :\
> anonymous - Anonymous code blocks really stand out. They are also called instance initialization blocks. They are run before the constructor is called.\
> named - We can also create blocks of code and give them a name.\
> static - Java has another code block called static code block as we use the static keyword for them.

subject.definition.methods= A method is a collection of statements that perform some specific task and return the result to\
   the caller. A method can perform some specific task without returning anything.
subject.information.methods=Methods allow us to reuse the code without retyping the code. In Java, every method must be part of some\
   class which is different from languages like C, C++, and Python.\
<br>Methods are time savers and help us to reuse the code without retyping the code.\
<br><b>Method Declaration</b>\
<br>In general, method declarations has six components :\
<br><b>- Modifier:</b> Defines access type of the method i.e. from where it can be accessed in your application.\
 <br>In Java, there 4 type of the access specifiers.\
<br><i>>public:</i> accessible in all class in your application.\
<br><i>>protected:</i> accessible within the class in which it is defined and in its subclass(es)\
<br><i>>private:</i> accessible only within the class in which it is defined.\
<br><i>>default (declared/defined without using any modifier):</i> accessible within same class and package within which its class is defined.\
<br><b>- The return type:</b> The data type of the value returned by the method or void if does not return a value.\
<br><b>- Method Name:</b>  the rules for field names apply to method names as well, but the convention is a little different.\
<br><b>- Parameter list:</b>  Comma separated list of the input parameters are defined, preceded with their data type, within the enclosed parenthesis. \
  If there are no parameters, you must use empty parentheses ().\
<br><b>- Exception list:</b>  The exceptions you expect by the method can throw, you can specify these exception(s).\
<br><b>- Method body:</b>  it is enclosed between braces. The code you need to be executed to perform your intended operations.\
<br><b> Method signature:</b>\
<br> It consists of the method name and a parameter list (number of parameters, type of the parameters and order of the parameters).\
   The return type and exceptions are not considered as part of it.\
<br><b>How to name a Method?:</b> \
 <br>A method name is typically a single word that should be a <i>verb</i> in lowercase or multi-word, \
  that begins with a <i>verb</i> in lowercase followed by <i>adjective, noun</i> ... After the first word, first letter of each word should be capitalized.\
 <br>For example, findSum,computeMax, setX and getX./\
  <br>Generally, A method has a unique name within the class in which it is defined but sometime a method might have the same name as \
  other method names within the same class as method overloading is allowed in Java.\
  <br><b>Calling a method</b>\
<br>The method needs to be called for using its functionality. There can be three situations when a method is called:\
<br> - A method returns to the code that invoked it when:\
<br> - It completes all the statements in the method\
<br> - It reaches a return statement\
<br> - Throws an exception
subject.example.methods= For example, one basic function of a computer is display information to the screen. Why should \
 we have to re-write that logic over and over? Instead, this Java declaration statement uses a delivered function to \
 display information on multiple lines.\
<br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
&ensp;System.out.println("Line 1");\
<br>&ensp;System.out.println("Line 2");</div>\
<br>And the output of the previous code.\
<br><b>Remember</b> - each Java statement ends with a semicolon.\
<br>We've just seen the basic variable declaration statement in action. Now let's look at another example you'll see a lot,\
   a Java string statement, or a collection of characters or objects: \
 <br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
 &emsp;String entryCode = new String();</div>

subject.definition.control.flow.statements=Generally the statements inside your java code are \
executed from top to bottom, in the order that they appear. Control flow statements, change or break \
the flow of execution by implementing decision making, looping, and branching your program to \
execute particular blocks of code based on the conditions.

subject.information.control.flow.statements=There are 3 types of control flow statements supported by the Java programming language.\
<br>•	Decision-making statements : if-then, if-then-else, switch\
<br>•	Looping statements : for, while, do-while\
<br>•	Branching statements : break, continue, return.

subject.example.control.flow.statements=If_then - The if-then statement is the most basic of all the control flow statements. It enables your program to execute a certain section of code depending on the state of variables, or values returned from methods.\
<br>If(iscar)\
<br>{\
<br>System.out.println(“I am a car”);\
<br>}\
<br>If isCar test evaluates to false, control jumps to the end of the if-then statement. In Java, the opening and closing braces are optional.But this is applicable only if the block of code to be executed is just a single statement. But as a good practice, it is advisable to put the brackets around the statements, even if there is only one statement to execute.This is because, in the begining you may start with one statement and later during the development phase you may add more statements. During this a common mistake would be forgetting to add the newly required braces which compiler cannot catch.\
\
<br>The if-then-else statement provides a alternate path of execution when an "if" clause evaluates to false. You can chain if-else statements, and create a decision tree sort of thing.\
\
<br>Switch statement - Another way to control the flow of your programs with decision-making statements is by a switch statement. A switch statement gives you the option to test for a range of values for your variables. If you think your if-else-if statements is long and complex, you can use switch statement instead.The body of a switch statement is known as a switch block. The switch statement evaluates its expression within the brackets, then executes all statements that follow the matching case label. Again there might be more than one cases being matched but switch will choose the first immidiate matching case ignoring the others.break statement is necessary.Because without it, statements in switch blocks fall through.\
\
<br>While statement - The while loop executes a set of statements while a certain conditions is true. In Java there are 2 variations of while loop: while and do-while loop. Here is a simple while loop example:\
\
<br>int counter = 0;\
<br>while(counter < 5) {\
<br>System.out.println(“Inside the while loop, counting: ” + counter);\
<br>counter ++;\
<br>}\
\
<br>This above while loop checks whether counter value is less than 5 to check if the statements inside while loop should be executed or not. If the counter value is less than 5, the while loop body is executed one more time else execution continues at the next statement after the while loop.\
\
<br>The other type of while loop is the do while loop:\
\
<br><br>int counter = 0;\
<br>do {\
<br>System.out.println(“Inside the while loop, counting: ” + counter);\
<br>counter ++;\
<br>\
<br>}while (counter < 5);\
<br><br>Notice the condition check is moved to end of while body in do-while construct. Which means statements inside the do while loop body is always executed at least once, and is then executed repeatedly while the while loop condition is true.\
This is the main difference between java while and do while loop, that the statements inside the do while loop is always executed at least once before the while loop condition is tested.\
For statement - The Java for loop repeats the execution of a set of Java statements. A for loop executes a block of code as long as some condition is true.\
for (initialization; termination condition; increment/decrement) {\
<br><span style="color:grey;">//java statement(s)</span>\
<br>}\
<br>The initialization expression initializes the loop and is executed only once at the begining when the loop begins. The termination condition is evaluated every loop and if it evaluates to false, the loop is terminated. And lastly increment/decrement expression is executed after each iteration through the loop.\
There are also branching statements: the break statement, the continue statement and the return statement.

subject.definition.classes= At its core, Java is an object-oriented language. It consists of objects, which are modules \
   that can have data and some instructions. An object should be able to sustain itself. An Employee object, for example,\
   contains some information about an employee. You can send salary, wage, benefit balances, etc. to the Employee object\
    and it can do something with that info.\
<br><i><b> A class,</b></i> on the other hand, is used to create objects. Think of a class as a blueprint for creating objects.\
  It represents the set of properties or methods that are common to all objects of one type.

subject.information.classes= Class declarations can include these components, in order:\
<br>&#10150 <i>Modifiers:</b></i> A class can be public or has default access (Refer this for details).\
<br>&#10150 <i>Class name:</i> The name should begin with a initial letter (capitalized by convention).\
<br>&#10150 <i>Superclass(if any):</i> The name of the class's parent (superclass), if any, preceded by the keyword extends. \
  A class can only extend (subclass) one parent.\
<br>&#10150 <i>Interfaces(if any):</i> A comma-separated list of interfaces implemented by the class, if any, preceded by the keyword \
  implements. A class can implement more than one interface.\
<br>&#10150 <i>Body:</i> The class body surrounded by braces, { }.\
Constructors are used for initializing new objects. Fields are variables that provides the state of the class and its objects,\
   and methods are used to implement the behavior of the class and its objects.
subject.example.classes=  In the following example, the object is really an Employee. However, we've created a class so that we\
   can structure the object to our needs.Check out our example below. You'll notice the different portions of the Java code underneath the Employee object.\
 <br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
<br>&ensp;public class Employee {\
<br>&ensp;public String empName; //Employee name\
<br>&emsp;public double hourly_rate, hours_worked;\
<br>&emsp;public double getWeeklyHours() {\
<br>&emsp;return (hourly_rate * hours_worked);\
<br>&emsp;}\
<br>&ensp;}<span style="color:grey;">//end of class</span></div>

subject.definition.constructors=
subject.information.constructors=
subject.example.constructors=

subject.definition.this.vs.super= <b>Super</b> keyword is used to access methods of the <i>parent class</i> while <b>this</b> is used to access methods \
  of the <i>current class.</i>\
<br><b>this keyword</b>\
<br>- this is a reserved keyword in java i.e, we can't use it as an identifier.\
<br>- this is used to refer current-class's instance as well as static members.\
<br><b>super keyword</b>\
<br>- super is a reserved keyword in java i.e, we can't use it as an identifier.\
<br>- super is used to refer super-class's instance as well as static members
subject.information.this.vs.super= <b><i>Similarities in <u>this</u> and <u>super</u></i></b>\
<br><b>1)</b> We can use this as well as super anywhere except static area. Example of this is already shown above where we\
   use this as well as super inside public static void main(String[]args) hence we get Compile Time Error since cannot use them inside static area.\
<br><b>2)</b> We can use this as well as super any number of times in a program.\
<br>\
<br><b>Note: </b>We can use <q>this</q> as well as <q>super</q> any number of times but main thing is that we cannot use them inside static context.
subject.example.this.vs.super=<b><i>this example</i></b>\
<br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
<br>&ensp;<span style="color:grey;">// Program to illustrate this keyword</span>\
<br>&ensp;<span style="color:grey;">// is used to refer current class</span>\
<br>&ensp;class RR {\
<br>&emsp;&ensp;<span style="color:grey;">// instance variable</span>\
<br>&emsp;&ensp;int a = 10;\
<br>\
<br>&emsp;&ensp;<span style="color:grey;">// static variable</span>\
<br>&emsp;&ensp;static int b = 20;\
<br>\
<br>&emsp;&emsp;void GFG()\
<br>&emsp;&emsp;{\
<br>&emsp;&emsp;<span style="color:grey;">// referring current class(i.e, class RR)</span>\
<br>&emsp;&emsp;<span style="color:grey;">// instance variable(i.e, a)</span>\
<br>&emsp;&emsp;this.a = 100;\
<br>\
<br>&emsp;&emsp;&ensp;System.out.println(a);\
<br>\
<br>&emsp;&emsp;&ensp;<span style="color:grey;">// referring current class(i.e, class RR)</span>\
<br>&emsp;&emsp;&ensp;<span style="color:grey;">// static variable(i.e, b)</span>\
<br>&emsp;&emsp;&ensp;this.b = 600;\
<br>\
<br>&emsp;&emsp;&ensp;&nbsp;System.out.println(b);\
<br>&emsp;&emsp;}\
<br>\
<br>&emsp;&emsp;public static void main(String[] args) \
<br>&emsp;&emsp;{\
<br>&emsp;&emsp;&ensp;<span style="color:grey;">// Uncomment this and see here you get  </span>\
<br>&emsp;&emsp;&ensp;<span style="color:grey;">// Compile Time Error since cannot use </span> \
<br>&emsp;&emsp;&ensp;<span style="color:grey;">// 'this' in static context. </span>\
<br>&emsp;&emsp;&ensp;<span style="color:grey;">// this.a = 700; </span>\
<br>&emsp;&emsp;&ensp;new RR().GFG(); \
<br>&emsp;&emsp;}\
<br>&ensp;}</div>\
 <br>\
<br><b><i>super example</i></b>\
  <br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
<br>&ensp;<span style="color:grey;">// Program to illustrate super keyword </span>\
<br>&ensp;<span style="color:grey;">// refers super-class instance</span>\
<br>\
<br> &ensp;class Parent {\
<br>&emsp;&ensp;<span style="color:grey;">// instance variable</span>\
<br>&emsp;&ensp;int a = 10;\
<br>\
<br>&emsp;&ensp;<span style="color:grey;">// static variable</span>\
<br>&emsp;&ensp;static int b = 20;\
<br>&ensp;}\
<br>\
<br>&ensp;class Base extends Parent {\
<br>&emsp;&ensp;void rr()\
<br>&emsp;&ensp;{\
<br>&emsp;&emsp;<span style="color:grey;">// referring parent class(i.e, class Parent)</span>\
<br>&emsp;&emsp;<span style="color:grey;">// instance variable(i.e, a</span>)\
<br>&emsp;&ensp;System.out.println(super.a);\
 <br>\
<br>&emsp;&emsp;<span style="color:grey;">// referring parent class(i.e, class Parent)</span>\
<br>&emsp;&emsp;<span style="color:grey;">// static variable(i.e, b)</span>\
<br>&emsp;&emsp;System.out.println(super.b);\
<br>&emsp;&ensp;}\
<br>\
<br>&emsp;&ensp;public static void main(String[] args)\
<br>&emsp;&ensp;{\
<br>&emsp;&emsp;<span style="color:grey;">// Uncomment this and see here you get</span>\
<br>&emsp;&emsp;<span style="color:grey;">// Compile Time Error since cannot use 'super'</span>\
<br>&emsp;&emsp;<span style="color:grey;">// in static context.</span>\
<br>&emsp;&emsp;<span style="color:grey;">// super.a = 700;</span>\
<br>&emsp;&emsp;new Base().rr();\
<br>&emsp;&ensp;}\
<br>&ensp;}</div>

subject.definition.inheritance=
subject.information.inheritance=
subject.example.inheritance=

subject.definition.method.overloading=<b> Overloading</b> allows different methods to have the same name, but different signatures \
  where the signature can differ by the number of input parameters or type of input parameters or both. Overloading is related to\
   compile-time (or static) polymorphism(see example below).
subject.information.method.overloading= There is a question that arises <q><b>What if the exact prototype does not match with arguments?</b></q>\
<br><b>Answer:</b> Priority wise, compiler take these steps:\
<br>1) Type Conversion but to higher type(in terms of range) in same family.\
<br>2) Type conversion to next higher family(suppose if there is no long data type available for an int data type, then it will \
  search for the float data type).\
  <br>\
<br> <b>What is the advantage?</b>\
We don't have to create and remember different names for functions doing the same thing. For example, in our code, if overloading \
  was not supported by Java, we would have to create method names like sum1, sum2, ... or sum2Int, sum3Int, ... etc.\
<br>\
<br> <b>Can we overload methods on return type?</b>\
<br>We cannot overload by return type. However, Overloading methods on return type are possible in cases where the data type \
  of the function being called is explicitly specified.\
  <br>\
<br> <b>Can we overload static methods?</b>\
<br>The answer is &rsquo;Yes&lsquo;. We can have two ore more static methods with same name, but differences in input parameters.\
<br>\
<br> <b>Can we overload methods that differ only by static keyword?</b>\
<br>We cannot overload two methods in Java if they differ only by static keyword (number of parameters and types of parameters is same).\
<br>\
<br> <b>Can we overload main() in Java?</b>\
Like other static methods, we can overload main() in Java.\
<br> <b>Does Java support Operator Overloading?</b>\
Unlike C++, Java doesn't allow user-defined overloaded operators. Internally Java overloads operators, for example, + is overloaded for concatenation.\
<br><b><i>!! Note:</i></b> Multiple methods can have the same name as long as the number and/or type of parameters are different.
subject.example.method.overloading= &ensp;class Demo {\
<br>&emsp;&ensp;public void show(int x)\
<br>&emsp;&ensp;{\
<br>&emsp;&ensp;System.out.println("In int" + x);\
<br>&emsp;&ensp;}\
<br>&emsp;&ensp;public void show(String s)\
<br>&emsp;&ensp;{\
<br>&emsp;&ensp;System.out.println("In String" + s);\
<br>&emsp;&ensp;}\
<br>&emsp;&ensp;public void show(byte b)\
<br>&emsp;&ensp;{\
<br>&emsp;&ensp;System.out.println("In byte" + b);\
<br>&ensp;}\
 <br>\
<br>&ensp;class UseDemo {\
<br>&emsp;&ensp;public static void main(String[] args)\
<br>&emsp;&ensp;{\
<br>&emsp;&emsp;&ensp;byte a = 25;\
<br>&emsp;&emsp;&ensp;Demo obj = new Demo();\
<br>&emsp;&emsp;&ensp;obj.show(a); <span style="color:grey;">// it will go to </span>\
<br>&emsp;&emsp;&ensp;obj.show("hello");<span style="color:grey;"> // String</span>\
<br>&emsp;&emsp;&ensp;obj.show(250); <span style="color:grey;">// Int</span>\
<br>&emsp;&emsp;&ensp;obj.show('A'); <span style="color:grey;">// Since char is not available, so the datatype</span>\
<br>&emsp;&emsp;&ensp;<span style="color:grey;">// higher than char in terms of range is int.</span>\
<br>&emsp;&emsp;&ensp;obj.show("A"); <span style="color:grey;">// String</span>\
<br>&emsp;&emsp;&ensp;obj.show(7.5); <span style="color:grey;">// since float datatype is not available and so</span>\
<br>&emsp;&ensp;<span style="color:grey;">// it's higher datatype, so at this step there will be an error.</span>\
<br>&emsp;&ensp;}\
<br>&ensp;}

subject.definition.method.overriding=
subject.information.method.overriding=
subject.example.method.overriding=

subject.definition.static.vs.instance.variables.and.methods=<b>Instance Method</b> are methods which require an object of its class to be created before \
  it can be called. To invoke an instance method, we have to create an Object of the class in within which it defined.\
  <br><b>Static methods</b> are the methods in Java that can be called without creating an object of class. They are referenced by\
  the class name itself or reference to the Object of that class.\
  <br><b>Static Variables:</b> When a variable is declared as static, then a single copy of the variable is created and shared among \
  all objects at a class level. Static variables are, essentially, global variables. All instances of the class share the same static variable.\
  <br><b>Instance variables</b> are non-static variables and are declared in a class outside any method, constructor or block.

subject.information.static.vs.instance.variables.and.methods=<b>Important Points for the Instance Method:</b>\
<br>&bull; Instance method(s) belong to the Object of the class not to the class i.e. they can be called after creating the Object of the class.\
<br>&bull; Every individual Object created from the class has its own copy of the instance method(s) of that class.\
<br>&bull; Instance methods are not stored on a per-instance basis, even with virtual methods. They're stored in a single memory \
  location, and they only &ldquo;know&rdquo; which object they belong to because the this pointer is passed when you call them.\
<br>&bull; They can be overridden since they are resolved using dynamic binding at run time.\
  <br>\
<br><b> Important Points for the Static methods:</b>\
<br>&bull; Static method(s) are associated to the class in which they reside i.e. they can be called even without creating an \
  instance of the class i.e ClassName.methodName(args).\
<br>&bull; They are designed with aim to be shared among all Objects created from the same class.\
<br>&bull; Static methods can not be overridden. But can be overloaded since they are resolved using static binding by compiler at compile time.\
<br>\
 <br><b>Instance method vs Static method</b>\
<br>&bull; Instance method can access the instance methods and instance variables directly.\
<br>&bull; Instance method can access static variables and static methods directly.\
<br>&bull; Static methods can access the static variables and static methods directly.\
<br>&bull; Static methods can't access instance methods and instance variables directly. They must use reference to object.\
   And static method can't use this keyword as there is no instance for &lsquo;this&rsquo;to refer to.\
 <br>\
 <br><b> Important points for Static  Variables:</b>\
<br>&bull; We can create static variables at class-level only. \
<br>&bull; Static block and static variables are executed in order they are present in a program.\
  <br>\
<br><b>Important points for Instance Variables:</b>\
<br>&bull; As instance variables are declared in a class, these variables are created when an object of the class is created and destroyed when the object is destroyed.\
<br>&bull; Unlike local variables, we may use access specifiers for instance variables. If we do not specify any access specifier then the default access specifier will be used.\
<br>&bull; Initialization of Instance Variable is not Mandatory. Its default value is 0\
<br>&bull; Instance Variable can be accessed only by creating objects.
subject.example.static.vs.instance.variables.and.methods=

subject.definition.encapsulation= The meaning of Encapsulation, is to make sure that "sensitive" data is hidden from users. To achieve this, you must:\
<br>&rArr; declare class variables/attributes as private\
<br>&rArr; provide public get and set methods to access and update the value of a private variable.

subject.information.encapsulation= <b>Get and Set</b>\
<br>You learned from the previous chapter that private variables can only be accessed within the same class (an outside class has\
   no access to it). However, it is possible to access them if we provide public get and set methods.\
The get method returns the variable value, and the set method sets the value.\
Syntax for both is that they start with either get or set, followed by the name of the variable, with the first letter in upper case (see example below).

subject.example.encapsulation= <i>Example</i>\
<br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
<br>&nbsp;public class Person {\
<br>&emsp;private String name; <span style="color:grey;">// private = restricted access</span>\
<br>&emsp;<span style="color:grey;">// Getter</span>\
<br>&emsp;public String getName() {\
<br>&emsp;return name;\
<br>&emsp;}\
<br>&emsp;<span style="color:grey;">// Setter</span>\
<br>&emsp;public void setName(String newName) {\
<br>&emsp;this.name = newName;\
<br>&emsp;}\
<br>&nbsp;}</div>\
<br><u>!! Example explained</u>\
<br>The get method returns the value of the variable name.\
The set method takes a parameter (newName) and assigns it to the name variable. The this keyword is used to refer to the current object.\
However, as the name variable is declared as private, we cannot access it from outside this class:\
  <br>\
<br><i>Example</i>\
<br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
<br>&nbsp;public class MyClass {\
<br>&emsp;public static void main(String[] args) {\
<br>&emsp;&ensp;Person myObj = new Person();\
<br>&emsp;&ensp;myObj.name = "John"; <span style="color:grey;"> // error</span>\
<br>&emsp;&ensp;System.out.println(myObj.name);<span style="color:grey;"> // error</span> \
<br>&emsp;}\
<br>&nbsp;}</div>\
<br>If the variable was declared as public, we would expect the following output: John.\
<br>However, as we try to access a private variable, we get an error:\
<br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
<br>&emsp;MyClass.java:4: error: name has private access in Person\
<br>&emsp;&ensp;myObj.name = "John";\
<br>&emsp;&emsp;^</div>\
<br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
<br>&emsp;MyClass.java:5: error: name has private access in Person\
<br>&emsp;&ensp;System.out.println(myObj.name);\
<br>&emsp;&emsp;^\
<br>&nbsp;<span style="color:grey;">//2 errors</span></div>\
<br>Instead, we use the getName() and setName() methods to acccess and update the variable:\
<br>\
<br><i>Example</i>\
<br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
<br>&nbsp;public class MyClass {\
<br>&emsp;public static void main(String[] args) {\
<br>&emsp;&ensp;Person myObj = new Person();\
<br>&emsp;&ensp;myObj.setName("John"); <span style="color:grey;">// Set the value of the name variable to "John"</span>\
<br>&emsp;&ensp;System.out.println(myObj.getName());\
<br>&emsp;}\
<br>&nbsp;}\
<br>&nbsp;<span style="color:grey;">// Outputs "John"</span></div>

subject.definition.polymorphism= Polymorphism has been derived from a biological term that means ability of an organism to\
   adopt multiple forms. In Java, polymorphism refers to the ability of referring and processing multiple objects and classes \
  through a unified interface. Any object that satisfies multiple IS-A relationships is a candidate of being implemented as a polymorphic\
   object. For instance, the object of class Square IS-A Square; It IS-A Shape as well and It IS-An object as well. It means that Object\
   and Shape can be declared parent classes of child Square classes. Therefore, a common interface Object can be used to refer to all\
   objects of Square class. Also, Shape interface can also be used to refer to all objects of Square class and so on.\
   This is due to the IS-A relationship of Square with Object and Shape classes.
subject.information.polymorphism= &loz;There are two types of polymorphism in Java: <i>Static Polymorphism and Dynamic Polymorphism.</i>\
   <br>\
<br><b>Static Polymorphism</b>\
<br>The static polymorphism (also known as compile time polymorphism) is implemented via overloaded methods of a class. \
  Method overloading refers to multiple methods with same name having different number or types of parameters. When the overloaded\
   method is called, Java compiler checks itself that which method has to be invoked that matches the parameters of the called method. \
  The following example demonstrates the concept of Static Polymorphism.\
<br>\
<br>Consider a Maths class that contains three Add methods. First method returns an integer and takes two integer types variable. \
  The second Add method also returns and integer but takes three integer types variables and the third Add method returns a \
  String and takes two string type parameters. Thus, all the Add methods have different number of types of parameters. These three \
 Add methods are called overloaded methods (see example one).\
<br>\
  <br><b>Dynamic Polymorphism</b>\
<br>Dynamic Polymorphism is implemented in Java using overridden methods. Method overrides refer to the process of providing the same\
   method name but with different parameters.\
<br>For instance, there is a parent Shape class that contains a method Draw. A derived Square class extends the Shape class and \
  implements its own Draw method which means that Square class overrides the Draw method of the parent Shape class. There is another\
   derived class of Shape class which is a Circle class and this class also overrides the Draw method of the parent class.\
<br> Now, if the reference of the Shape class is used to refer to the object of the Square class and then Draw method is called, \
  the Draw method of the Square class will be called. However, if Shape class object is used to refer to the object of Circle class \
  and then Draw method is called on that, the Draw method of the circle class will be called. In other words, different functionality \
  of Draw method would be achieved through a single unified interface. The following code snippet demonstrates this concept(see example 2).
subject.example.polymorphism= <i>Example 1</i>\
<br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
<br>&ensp;}public class Maths {\
<br>&emsp;&ensp;public int Add (int num1, int num2)\
<br>&emsp;&ensp;{\
<br>&emsp;&ensp;&nbsp;return num1 + num2;\
<br>&emsp;&ensp;}\
<br>&emsp;&ensp;public int Add(int num1, int num2, int num3)\
<br>&emsp;&ensp;{\
<br>&emsp;&ensp;&nbsp;return num1 + num2 + num3;\
<br>&emsp;&ensp;}\
<br>&emsp&ensp;;public String Add (String s1, String s2)\
<br>&emsp;&ensp;{\
<br>&emsp;&ensp;&nbsp;return s1 + s2;\
<br>&emsp;&ensp;}\
<br>&ensp;}</div/>\
<br>\
<br><i>Example 2</i>\
<br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
<br>&ensp;public class Shape {\
<br>&emsp;&ensp;public void Draw()\
<br>&emsp;&ensp;{\
<br>&emsp;&ensp;System.out.println ("A shape is being drawn");\
<br>&emsp;&ensp;}\
<br>&ensp;}\
<br><span style="color:grey;">//The Square and Circle classes extend this Shape class as follows:</span>\
<br>&ensp;public class Square extends Shape\
<br>&ensp;{\
<br>&emsp;&ensp;public void Draw()\
<br>&emsp;&ensp;{\
<br>&emsp;&ensp;&nbsp;System.out.println ("A Square is being drawn");\
<br>&emsp;&ensp;\
<br>&emsp;&ensp;}\
<br>&ensp;public class Circle extends Shape\
<br>&ensp;{\
<br>&emsp;&ensp;public void Draw()\
<br>&emsp;&ensp;{\
<br>&emsp;&ensp;&nbsp;System.out.println ("A Circle is being drawn");\
<br>&emsp;&ensp;}\
<br>&ensp;}</div>

subject.definition.autoboxing.and.unboxing= \
 <br>&#10022; <b>Autoboxing</b> is converting a primitive value into an object of the corresponding wrapper class is called autoboxing. \
 <br>&#10022; <b>Unboxing</b> is converting an object of a wrapper type to its corresponding primitive value is called unboxing.

subject.information.autoboxing.and.unboxing=\
<br>To convert an int to Integer class the Java compiler applies <i><u><b>autoboxing</b></u></i> when a primitive value is:\
<br> &#10147; Passed as a parameter to a method that expects an object of the corresponding wrapper class.\
<br> &#10147; Assigned to a variable of the corresponding wrapper class.\
<br>\
<br>For the conversion of Integer to int the Java compiler applies <i><u><b>unboxing</b></u></i> when an object of a wrapper class is:\
<br> &#10147; Passed as a parameter to a method that expects a value of the corresponding primitive type.\
<br> &#10147; Assigned to a variable of the corresponding primitive type.\
<br> The following table lists the primitive types and their corresponding wrapper classes, which are used by the Java\
   compiler for autoboxing and unboxing:\
<br>\
<img style="width:350px; height:400px; border:3px solid grey; border-radius: 18px; margin-top:17px;"  src="/images/Wrapper.png">\
<br>\
<br> <b>Advantages of Autoboxing / Unboxing:</b>\
<br> &#10147; Autoboxing and unboxing lets developers write cleaner code, making it easier to read.\
<br> &#10147; The technique let us use primitive types and Wrapper class objects interchangeably and we do not need to perform any typecasting explicitly.
subject.example.autoboxing.and.unboxing=<br><br><div style = "background:#daedf0; font-style:italic; border:1px solid grey; border-radius: 10px;">\
<br>&ensp;<span style="color:grey;">// Java program to illustrate the concept of Autoboxing and Unboxing</span> \
<br>&ensp;import java.io.*; \
<br>\
<br>&ensp;class GFG \
<br>&ensp;{\
<br>&emsp;&nbsp;public static void main (String[] args) \
<br>&emsp;&nbsp;{\
<br>&emsp;&emsp;<span style="color:grey;">// creating an Integer Object with value 10. </span>\
<br>&emsp;&emsp;Integer i = new Integer(10); \
<br>\
<br>&emsp;&emsp;<span style="color:grey;">// unboxing the Object </span>\
<br>&emsp;&emsp;int i1 = i; \
<br>\
<br>&emsp;&emsp;System.out.println("Value of i: " + i); \
<br>&emsp;&emsp;System.out.println("Value of i1: " + i1); \
<br>\
<br>&emsp;&emsp;<span style="color:grey;">//Autoboxing of char </span>\
<br>&emsp;&emsp;Character gfg = 'a'; \
<br>\
<br>&emsp;&emsp;<span style="color:grey;">// Auto-unboxing of Character </span>\
<br>&emsp;&emsp;char ch = gfg; \
<br>&emsp;&emsp;System.out.println("Value of ch: " + ch); \
<br>&emsp;&emsp;System.out.println("Value of gfg: " + gfg); \
<br>\
<br>&emsp;&nbsp;}\
<br>}</div>


subject.definition.collections=
subject.information.collections=
subject.example.collections=


subject.definition.generics=
subject.information.generics=
subject.example.generics=

subject.definition.java.fx=
subject.information.java.fx=
subject.example.java.fx=

subject.definition.concurrency=
subject.information.concurrency=
subject.example.concurrency=

subject.definition.lambda.expressions=
subject.information.lambda.expressions=
subject.example.lambda.expressions=
</head>